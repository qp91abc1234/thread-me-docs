## 代码分割策略

代码分割的主要好处：
- **提升缓存命中率**：将第三方依赖按功能分组打包，当某个依赖更新时，只需重新加载对应的 chunk，其他未变更的 chunk 仍可使用缓存
- **减少加载无用代码**：通过按页面分包和动态导入，用户只需加载当前页面所需的代码，避免一次性加载所有页面代码，减少首屏加载时间

分割前提：
根据产物分析结果进行手动分包，不仅看“体积”，也看缓存命中是否稳定

### 首屏分包：业务代码与第三方依赖分离
目标：**首屏更轻 + 第三方依赖更稳定可缓存**。

- **原则**：
  - 首屏入口里以**业务代码**为主；将**第三方依赖**抽离到相对稳定的 chunk，减少入口更新带来的缓存失效
  - `manualChunks` 只在“收益明确”时使用，避免拆得过碎导致请求数上升、解析开销变大
- **第三方依赖进一步分层**：
  - **非按需导入 / 首屏必需**：可按“功能域”分组（例如 vue 栈、网络/工具等），提升缓存复用
  - **按需导入的依赖（如 element-plus）**：
    - 优先依赖**编译期按需引入 + tree-shaking**，不要把整库当成首屏必需一次性打进大 chunk
    - 若某些组件仅在少数页面使用，倾向让它们随页面懒加载，而不是进入首屏 vendor

### 非首屏分包：异步路由 + 动态模块导入
目标：**非首屏不加载**，只在需要时拉取（尤其是“大模块/大依赖”）。

- **按页面分包（路由级）**：通过异步路由（`component: () => import('@/views/xxx.vue')`）实现页面级拆分
- **页面内二次拆分（模块级）**：若页面本身仍偏大，进一步用动态导入（`import()` / `defineAsyncComponent`）把大块组件或大 npm（如富文本编辑器）延后加载