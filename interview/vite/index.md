## Vite 核心原理

### 1. 为什么快？
Vite 的快主要体现在**开发环境**的冷启动和热更新（HMR）上，核心在于利用浏览器原生的 ES Modules 能力。

#### 快速冷启动（No-Bundle）
- **传统方式（Webpack）**：冷启动时需要递归分析整个依赖图，进行编译、打包（Bundle），项目越大启动越慢。
- **Vite 方式**：
  - **按需编译**：不打包，直接启动开发服务器。
  - **原生 ESM**：利用浏览器支持 `<script type="module">` 的特性，当浏览器请求某个模块时，Vite 才对该模块进行**按需编译**并返回。
  - **结果**：启动时间与项目复杂度解耦，几乎是 O(1) 的启动速度。

#### 高效热更新（HMR）
- **传统方式**：修改文件后，通常需要重新构建该模块及其依赖链，并刷新 Bundle。
- **Vite 方式**：
  - **精准更新**：修改文件后，Vite 只需要让浏览器重新请求该变更模块（加上时间戳 query）。
  - **HTTP 缓存**：利用浏览器 HTTP 缓存（源码模块协商缓存 `304`，依赖模块强缓存 `Cache-Control: max-age=...`），未变更的模块直接读取缓存。

### 2. 依赖预构建（Pre-Bundling）
Vite 在启动开发服务器前，会使用 **esbuild** 对第三方依赖（node_modules）进行预构建。

#### 核心目的
1. **模块化兼容（CommonJS -> ESM）**：
   - 将 CommonJS 或 UMD 格式的依赖转换为原生 ESM，以便浏览器可以直接加载。
2. **性能优化（合并请求）**：
   - 将由数百个内部小文件组成的依赖（如 `lodash-es`）合并为一个或少数几个 Chunk，减少浏览器的 HTTP 请求数量，避免网络拥塞。

#### 缓存机制
- **文件系统缓存**：构建结果缓存到 `node_modules/.vite`，依据 `package.json`、`lockfile`、`vite.config.ts` 的变化来决定是否重新构建。
- **路径重写**：将导入路径重写为绝对路径（指向 `.vite/deps`），解决浏览器不支持裸模块导入（如 `import _ from "lodash"`）的问题。

### 3. Vite vs Webpack 核心区别

#### 开发模式（Dev Server）
- **Webpack**：**Bundle-Based**。先打包再启动服务器。修改代码时，需要重新编译受影响的模块并更新 Bundle。
- **Vite**：**Native-ESM-Based**。先启动服务器，利用浏览器去请求模块。修改代码时，仅需**按需编译**当前模块，无打包过程。

#### 构建工具（Build）
- **Webpack**：使用自身（JS编写）进行打包，配置灵活但性能受限于 JS 单线程。
- **Vite**：
  - **开发环境**：使用 **esbuild**（Go编写）进行预构建，速度极快（比 JS 快 10-100 倍）。
  - **生产环境**：使用 **Rollup** 进行打包，提供成熟的代码分割和 CSS 处理能力。

#### 生态与配置
- **Webpack**：配置极其灵活但也极其复杂，Loader/Plugin 生态庞大，适合大型复杂项目定制。
- **Vite**：开箱即用，内置了对 TS、CSS、JSX 的支持，配置简洁，插件基于 Rollup 接口，生态正在快速壮大。