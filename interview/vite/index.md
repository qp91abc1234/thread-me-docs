## vite vs webpack

- **vite**：现代前端构建工具，基于两个前提条件：目标环境是支持 **ES Module** 的现代浏览器；依赖模块默认是 **ES Module** 格式
- **Webpack**：通用 JS 打包器，不确定依赖模块的模块化范式，必须自己实现模块加载机制来抹除所有模块化范式间的差异

## vite 为什么快

### 开发服务器启动快
- **Webpack**：启动前需打包整个应用（分析依赖、编译、打包）
- **Vite**：基于原生 **ES 模块**，无需打包直接启动（依赖预构建 + 根据模块树按需编译），仅启动一个轻量服务器

### 热更新（HMR）快
- **Webpack**：需重新编译变动的模块及其依赖链，然后打包推送
- **Vite**：利用浏览器原生 **ES 模块**，按需编译并替换单个模块，更新速度与项目大小无关

## 依赖预构建

### 兼容性转换
将 **CommonJS** / **UMD** 等格式的第三方依赖，统一转换为标准的 **ES 模块**格式，使浏览器可以直接运行。

### 请求合并
将大量分散的第三方模块文件（如 `lodash` 的数百个子文件）合并成少数几个文件，减少 HTTP 请求数量，避免浏览器并发请求瓶颈。

### 路径重写
将裸模块导入（如 `import vue from 'vue'`）重写为预构建产物的绝对路径（如 `/node_modules/.vite/vue.js`），让浏览器能直接定位和加载。

### 缓存加速
预构建结果会缓存到 `node_modules/.vite` 目录。后续启动项目时直接使用缓存，跳过重复构建，极大提升冷启动和重复安装依赖的速度。

## vite 热更新流程

1. **监听文件**：Vite 开发服务器监听到文件变化
2. **按需编译**：服务器仅对这个变化文件进行快速编译转换
3. **发送通知**：服务器通过 **WebSocket** 向浏览器发送一条简单的 HMR 消息："模块 xxx 已更新"
4. **发起请求**：浏览器收到通知后，自动通过 HTTP 请求向服务器获取更新的模块代码
5. **执行更新**：执行新的模块代码得到组件定义，Vite 的 HMR 运行时（客户端代码）根据现有数据以及组件定义触发 Vue 组件的重新渲染，完成热更新

## 兼容旧版本

### 代码兼容
- **webpack**：通过 `babel-loader` 转译代码文件
- **vite**：通过 `legacy` 插件，生成两份打包产物，在 HTML 中通过 `type="module"` 和 `nomodule` 属性区分，现代浏览器加载现代版本，旧浏览器加载 legacy 版本

本质都是通过 **babel** 进行语法转译和 polyfill 注入。

**babel 降级流程**：将代码 parse 为 AST 树，根据 `browserslist` 配置通过插件转换 AST 为目标版本的 AST，最后将 AST 生成目标版本代码。

### 样式兼容
- **webpack**：通过 `postcss-loader` 处理 CSS 文件
- **vite**：会自动读取项目根目录下的 `postcss.config.mjs` 文件，并将配置应用到所有 CSS 文件的处理过程中

通过 **postcss**（CSS 后处理器）来完成，主要是做 CSS 降级（如 `postcss-preset-env`）和添加浏览器前缀（如 `autoprefixer`）。

## 代码分包

### 作用
- **复用缓存**：首包业务和依赖分离，使依赖缓存稳定命中
- **避免加载无关代码**：路由分包，其他页面的代码不会被加载

### 分类
- **路由级分包**
- **组件级分包**
  - 针对异步大组件，可采用动态 `import` 进行延迟加载
- **依赖分包**
  - 需考虑按需导入，避免全量加载

### 分包检查
通过可视化工具对产物进行检查，来进一步细化分包
